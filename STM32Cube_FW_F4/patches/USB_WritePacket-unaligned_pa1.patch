From: pavel_a <pavel_a>
Date: 14 May 2019
Quick fix for fault caused by unaligned 32-bit read in stm32f4xx_ll_usb.c, USB_WritePacket
Maybe a better way to avoid it is having the caller to pass the data properly aligned.
This patch is for F4 v.1.21; similar but different needed for v.1.24.0  and others.

--- a/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c
+++ b/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usb.c
@@ -878,15 +878,36 @@
 {
   uint32_t count32b = 0U , i = 0U;
   
   if (dma == 0U)
   {
     count32b =  (len + 3U) / 4U;
+    if (((uint32_t)src & 3) == 0) {
     for (i = 0U; i < count32b; i++, src += 4U)
     {
-      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
+      USBx_DFIFO(ch_ep_num) = *((uint32_t *)src);
+    }
+    } else if ((((uint32_t)src & 1) == 0)) {
+        /* UNALIGNED fix - 2 bytes */
+        for (i = 0U; i < count32b; i++)
+        {
+            uint32_t v;
+            v = (uint32_t)(*(uint16_t*)src);
+			src += 2;
+			v |= (uint32_t)(*(uint16_t*)src) << 16;
+			src += 2;
+            USBx_DFIFO(ch_ep_num) = v;
+        }
+    } else { /* UNALIGNED fix - odd byte */
+        uint8_t oddbyte = *src++;
+        for (i = 0U; i < count32b; i++, src += 4U)
+        {
+            uint32_t v = *(uint32_t*)src;
+            USBx_DFIFO(ch_ep_num) = (v << 8) | oddbyte;
+			oddbyte = (uint8_t)(v >> 24);
+		}
     }
   }
   return HAL_OK;
 }
 
 /**
